<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>City Path Planning — Futuristic Demo</title>
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Inter:wght@300;600;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#030617;
    --panel:#061226;
    --muted:#7fb2d9;
    --neon:#4dd0ff;
    --neon-2:#6ef6c1;
    --accent:#8da9ff;
    --danger:#ff6b6b;
    --glass: rgba(255,255,255,0.03);
    --glass-2: rgba(77,208,255,0.04);
    --card-shadow: 0 12px 40px rgba(3,8,16,0.7);
    --glass-border: 1px solid rgba(77,208,255,0.06);
  }

  /* Page layout */
  html,body{height:100%; margin:0; background:linear-gradient(180deg,#020410 0%, #031026 100%); color:#dff6ff; font-family:Inter,system-ui,Segoe UI,Roboto,Arial; -webkit-font-smoothing:antialiased;}
  .page { max-width:1180px; margin:18px auto; display:flex; flex-direction:column; gap:18px; padding:10px; }
  header { display:flex; align-items:center; justify-content:space-between; gap:12px; }
  .brand { display:flex; gap:12px; align-items:center; }
  .logo { width:52px; height:52px; border-radius:10px; background:linear-gradient(135deg,var(--neon),var(--neon-2)); display:flex; align-items:center; justify-content:center; color:#021; font-weight:800; box-shadow:0 6px 20px rgba(77,208,255,0.12), inset 0 -4px 12px rgba(0,0,0,0.25); font-family:'Share Tech Mono', monospace; }
  .title { font-weight:700; letter-spacing:0.6px; font-size:18px; color:var(--neon); }
  .subtitle { font-size:12px; color:var(--muted); margin-top:2px; }

  /* Main content area: centered map + thin control bar */
  .main { display:flex; justify-content:center; align-items:flex-start; gap:18px; }
  .map-card { width:760px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:12px; padding:12px; border:var(--glass-border); box-shadow:var(--card-shadow); display:flex; flex-direction:column; align-items:center; }
  /* Center the canvas inside */
  #gridCanvas { width:720px; height:480px; border-radius:10px; background:linear-gradient(180deg,#051422,#082433); box-shadow: inset 0 1px 0 rgba(255,255,255,0.02), 0 8px 30px rgba(3,8,16,0.6); display:block; border:1px solid rgba(77,208,255,0.04); image-rendering:pixelated; }

  /* tiny neon control bar */
  .controls { width:100%; display:flex; align-items:center; gap:10px; margin-bottom:8px; justify-content:space-between; }
  .controls .left { display:flex; gap:8px; align-items:center; }
  button, select, input[type=range] { background:transparent; color:var(--neon); border:1px solid rgba(77,208,255,0.07); padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:700; font-size:12px; letter-spacing:0.6px; }
  button.primary { background:linear-gradient(90deg,var(--neon),var(--neon-2)); color:#002; border:0; box-shadow:0 8px 18px rgba(77,208,255,0.08); }
  .small { font-size:12px; color:var(--muted); }

  /* right side small stats */
  .status { display:flex; gap:10px; align-items:center; }
  .stat-pill { background:linear-gradient(180deg, rgba(77,208,255,0.02), rgba(77,208,255,0.01)); padding:6px 10px; border-radius:8px; border:1px solid rgba(77,208,255,0.03); font-weight:700; color:var(--neon); font-size:13px; }

  /* Scrollable info area below the map */
  .info { margin-top:6px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00)); border-radius:10px; padding:14px; border:1px solid rgba(255,255,255,0.03); color:var(--muted); box-shadow:0 10px 30px rgba(1,6,12,0.6); max-height:420px; overflow:auto; }
  .info h2 { margin:2px 0 8px 0; color:var(--accent); font-size:16px; }
  .info pre { background:rgba(0,0,0,0.25); padding:12px; border-radius:8px; color:#dff6ff; overflow:auto; font-size:13px; }
  .info .section { margin-bottom:12px; }
  .tag { display:inline-block; padding:6px 8px; border-radius:8px; background:rgba(77,208,255,0.06); color:var(--neon); font-weight:700; margin-right:8px; font-size:12px; }

  footer { text-align:center; color:var(--muted); font-size:12px; margin-top:4px; }

  /* futuristic grid lines overlay */
  #overlay { position:relative; pointer-events:none; margin-top:-498px; width:720px; height:480px; border-radius:10px; mix-blend-mode:overlay; opacity:0.06; }

  /* Responsive */
  @media(max-width:980px){ .page{padding:8px} .wrap{width:100%;} .map-card{width:100%} #gridCanvas{width:100%; height:auto} #overlay{display:none} }
</style>
</head>
<body>
  <div class="page">
    <header>
      <div class="brand">
        <div class="logo">CP</div>
        <div>
          <div class="title">City Path Planning — A* Replanning</div>
          <div class="subtitle">Design & Analysis of Algorithms — Demo (5th sem)</div>
        </div>
      </div>
      <div class="status">
        <div class="stat-pill" id="tickPill">Tick: 0</div>
        <div class="stat-pill" id="replanPill">Replans: 0</div>
        <div class="stat-pill" id="nodesPill">Nodes: 0</div>
      </div>
    </header>

    <main class="main">
      <section class="map-card" role="main" aria-label="Path planning map">
        <div class="controls" aria-hidden="false">
          <div class="left">
            <button id="startBtn" class="primary">START</button>
            <button id="pauseBtn">PAUSE</button>
            <button id="stepBtn">STEP</button>
            <button id="regenBtn">REGEN CITY</button>
            <label class="small" style="margin-left:8px">Obstacles:
              <select id="obsCount"><option value="4">4</option><option value="8" selected>8</option><option value="12">12</option><option value="18">18</option></select>
            </label>
          </div>

          <div class="status" style="gap:8px">
            <div class="small">Speed</div>
            <input id="speedRange" type="range" min="1" max="30" value="10" />
          </div>
        </div>

        <div style="position:relative; display:flex; justify-content:center; align-items:center;">
          <canvas id="gridCanvas" width="720" height="480" aria-label="Grid world canvas"></canvas>
          <!-- subtle overlay for futuristic vibe -->
          <canvas id="overlay" width="720" height="480"></canvas>
        </div>

        <div class="info" id="infoPanel" aria-live="polite">
          <div class="section">
            <span class="tag">Model</span>
            <strong>Dynamic A* Replanning on Random City Map</strong>
            <p>Map: procedurally generated roads/buildings/parks/water. Vehicle: point-car moving cell-to-cell. Planner: A* (Manhattan). When the next cell is blocked by a moving obstacle, the system replans from the current position.</p>
          </div>

          <div class="section">
            <span class="tag">How to use</span>
            <ol>
              <li>Click <strong>REGEN CITY</strong> to make a new map.</li>
              <li>Left-click any road cell to set <strong>START</strong>. Right-click any road cell to set <strong>GOAL</strong>.</li>
              <li>Click <strong>START</strong> to run; <strong>STEP</strong> advances one tick; <strong>PAUSE</strong> stops the simulation.</li>
            </ol>
          </div>

          <div class="section">
            <span class="tag">Pseudocode</span>
            <pre>
Main Loop:
  while not reached_goal:
    move_dynamic_obstacles()
    update_occupancy()
    if path is null or next_cell_blocked:
      path = A_STAR(current_pos, goal, grid)
      if path found: replans++
    if path exists:
      move to next cell on path
    else:
      wait (obstacles may move away)
            </pre>
          </div>

          <div class="section">
            <span class="tag">What to include in report</span>
            <ul>
              <li>Algorithm description (A*, heuristic, complexity).</li>
              <li>Replanning strategy and its limitations.</li>
              <li>Experiment: vary obstacle density (4,8,12,18) and record replans, nodes expanded, planning time.</li>
              <li>Screenshots: initial path, blocked path, replanned path.</li>
            </ul>
          </div>

          <div class="section">
            <span class="tag">Extensions</span>
            <p>You can ask me to add CSV logging, a D* Lite incremental planner for performance comparison, or a smoothed path (spline) and kinematic model (bicycle model).</p>
          </div>
        </div>
      </section>
    </main>

    <footer>Made for DA&amp;A — 5th Sem demo • Click on the map area to set start/goal • Right-click sets goal</footer>
  </div>

<script>
/* Single-file demo behavior (clean + robust)
   - City generator, A* + replanning
   - Centered canvas, neon styling, info panel below
*/
(() => {
  // DOM
  const canvas = document.getElementById('gridCanvas');
  const ctx = canvas.getContext('2d');
  const overlay = document.getElementById('overlay');
  const octx = overlay.getContext('2d');

  const tickPill = document.getElementById('tickPill');
  const replanPill = document.getElementById('replanPill');
  const nodesPill = document.getElementById('nodesPill');
  const statsText = document.getElementById('infoPanel');

  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const stepBtn = document.getElementById('stepBtn');
  const regenBtn = document.getElementById('regenBtn');
  const obsCount = document.getElementById('obsCount');
  const speedRange = document.getElementById('speedRange');

  // Config
  let COLS = 30, ROWS = 20;
  const CANVAS_W = canvas.width, CANVAS_H = canvas.height;
  let CELL_W = Math.floor(CANVAS_W / COLS), CELL_H = Math.floor(CANVAS_H / ROWS);

  // state
  let baseGrid = []; // 0 road, 1 building, 3 park, 4 water
  let grid = []; // base + dynamic obstacles (2)
  let obstacles = [];
  let start = {r:0,c:0}, goal = {r:ROWS-1,c:COLS-1}, vehicle = {r:0,c:0};
  let path = null; let stepIndex = 1;
  let running = false, tick = 0, replans = 0, nodesLast = 0, lastTime = 0;
  let timer = null;

  function randInt(a,b){ return Math.floor(a + Math.random()*(b-a+1)); }
  function shuffle(a){ for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
  function inBounds(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS; }

  // City generator
  function generateCity(){
    baseGrid = Array.from({length:ROWS}, ()=>Array.from({length:COLS}, ()=>1));
    // horizontal roads
    let r = randInt(1,3);
    while(r < ROWS-1){
      const thick = Math.random()<0.6?2:1;
      for(let t=0;t<thick && r+t<ROWS;t++){
        for(let c=0;c<COLS;c++) baseGrid[r+t][c]=0;
      }
      r += randInt(3,6);
    }
    // vertical roads
    let c = randInt(2,4);
    while(c < COLS-1){
      const thick = Math.random()<0.6?2:1;
      for(let t=0;t<thick && c+t<COLS;t++){
        for(let rr=0; rr<ROWS; rr++) baseGrid[rr][c+t]=0;
      }
      c += randInt(3,7);
    }
    // parks/water
    const blocks=[];
    for(let rr=0; rr<ROWS; rr++) for(let cc=0; cc<COLS; cc++) if(baseGrid[rr][cc]===1) blocks.push([rr,cc]);
    shuffle(blocks);
    const parks = Math.max(1, Math.floor(blocks.length*0.06));
    const waters = Math.max(1, Math.floor(blocks.length*0.03));
    for(let i=0;i<parks;i++){ const [rr,cc]=blocks[i]; baseGrid[rr][cc]=3; }
    for(let i=parks;i<parks+waters;i++){ const [rr,cc]=blocks[i]; baseGrid[rr][cc]=4; }
    // alleys
    for(let i=0;i<Math.floor((ROWS*COLS)*0.01);i++){ baseGrid[randInt(1,ROWS-2)][randInt(1,COLS-2)] = 0; }
  }

  // obstacles
  class Ob {
    constructor(r,c,pattern='line'){ this.r=r; this.c=c; this.pattern=pattern; const dirs=[{dr:1,dc:0},{dr:-1,dc:0},{dr:0,dc:1},{dr:0,dc:-1}]; this.dir = dirs[randInt(0,dirs.length-1)]; }
    step(){
      if(this.pattern==='random'){
        const choices=[{dr:0,dc:0},{dr:1,dc:0},{dr:-1,dc:0},{dr:0,dc:1},{dr:0,dc:-1}];
        const p = choices[randInt(0,choices.length-1)];
        const nr=this.r+p.dr, nc=this.c+p.dc;
        if(inBounds(nr,nc) && baseGrid[nr][nc]===0 && !(nr===vehicle.r && nc===vehicle.c) && !(nr===start.r&&nc===start.c) && !(nr===goal.r&&nc===goal.c)) { this.r=nr; this.c=nc; }
      } else {
        const nr=this.r+this.dir.dr, nc=this.c+this.dir.dc;
        if(!inBounds(nr,nc) || baseGrid[nr][nc]!==0 || (nr===vehicle.r&&nc===vehicle.c) || (nr===start.r&&nc===start.c) || (nr===goal.r&&nc===goal.c)) {
          this.dir.dr *= -1; this.dir.dc *= -1;
          const nr2=this.r+this.dir.dr, nc2=this.c+this.dir.dc;
          if(inBounds(nr2,nc2) && baseGrid[nr2][nc2]===0 && !(nr2===vehicle.r&&nc2===vehicle.c)) { this.r=nr2; this.c=nc2; }
        } else { this.r=nr; this.c=nc; }
      }
    }
  }

  function placeObstacles(n){
    obstacles=[];
    const free=[];
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(baseGrid[r][c]===0 && !(r===start.r&&c===start.c) && !(r===goal.r&&c===goal.c)) free.push([r,c]);
    shuffle(free);
    for(let i=0;i<n && i<free.length;i++){ const [r,c]=free[i]; const pattern=(i%2===0)?'line':'random'; obstacles.push(new Ob(r,c,pattern)); }
  }

  function updateGridWithObstacles(){
    grid = baseGrid.map(row => row.slice());
    for(const o of obstacles) if(inBounds(o.r,o.c)) grid[o.r][o.c] = 2;
  }

  // A* implementation
  function aStar(startNode, goalNode, gridState){
    const t0 = performance.now();
    const h = (a,b)=>Math.abs(a.r-b.r)+Math.abs(a.c-b.c);
    const dirs=[{dr:1,dc:0},{dr:-1,dc:0},{dr:0,dc:1},{dr:0,dc:-1}];
    const rows=gridState.length, cols=gridState[0].length;
    const key = n => `${n.r},${n.c}`;
    const heap=[]; function push(v){ heap.push(v); let i=heap.length-1; while(i>0){ const p=Math.floor((i-1)/2); if(heap[i].f>=heap[p].f) break; [heap[i],heap[p]]=[heap[p],heap[i]]; i=p; } }
    function pop(){ const top=heap[0]; const last=heap.pop(); if(heap.length>0){ heap[0]=last; let i=0; while(true){ const l=2*i+1,r=2*i+2; let s=i; if(l<heap.length && heap[l].f < heap[s].f) s=l; if(r<heap.length && heap[r].f < heap[s].f) s=r; if(s===i) break; [heap[i],heap[s]]=[heap[s],heap[i]]; i=s; } } return top; }
    function empty(){ return heap.length===0; }
    const g = new Map(), came = new Map();
    g.set(key(startNode),0); push({node:startNode, f:h(startNode,goalNode)});
    let nodes=0;
    while(!empty()){
      const cur = pop().node; nodes++;
      if(cur.r===goalNode.r && cur.c===goalNode.c){
        const p=[]; let ck = key(cur); p.push(cur);
        while(came.has(ck)){ const prev=came.get(ck); p.push(prev); ck = `${prev.r},${prev.c}`; }
        p.reverse();
        return {path: p, nodes, time:(performance.now()-t0)/1000};
      }
      for(const d of dirs){
        const nr=cur.r+d.dr, nc=cur.c+d.dc;
        if(!inBounds(nr,nc)) continue;
        if(gridState[nr][nc] !== 0 && !(nr===goalNode.r && nc===goalNode.c)) continue;
        const nk = `${nr},${nc}`, curk = `${cur.r},${cur.c}`;
        const tentative = (g.get(curk) || 1e9) + 1;
        if(tentative < (g.get(nk) || 1e9)){
          g.set(nk, tentative);
          came.set(nk, {r:cur.r,c:cur.c});
          push({node:{r:nr,c:nc}, f: tentative + h({r:nr,c:nc}, goalNode)});
        }
      }
    }
    return {path:null, nodes, time:(performance.now()-t0)/1000};
  }

  // Drawing functions
  function drawOverlay(){
    // faint grid lines for futuristic look
    octx.clearRect(0,0,overlay.width,overlay.height);
    octx.strokeStyle = 'rgba(77,208,255,0.06)';
    octx.lineWidth = 1;
    for(let x=0;x<=overlay.width;x+=Math.max(12, CELL_W)) { octx.beginPath(); octx.moveTo(x,0); octx.lineTo(x,overlay.height); octx.stroke(); }
    for(let y=0;y<=overlay.height;y+=Math.max(12, CELL_H)) { octx.beginPath(); octx.moveTo(0,y); octx.lineTo(overlay.width,y); octx.stroke(); }
  }

  function draw(){
    ctx.clearRect(0,0, CANVAS_W, CANVAS_H);
    CELL_W = Math.floor(CANVAS_W / COLS); CELL_H = Math.floor(CANVAS_H / ROWS);
    // base grid
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const x = c*CELL_W, y = r*CELL_H, t = baseGrid[r][c];
        if(t===0){ ctx.fillStyle = '#0f2936'; ctx.fillRect(x,y,CELL_W,CELL_H); }
        else if(t===1){ ctx.fillStyle = '#07141b'; ctx.fillRect(x,y,CELL_W,CELL_H); }
        else if(t===3){ ctx.fillStyle = '#073a2d'; ctx.fillRect(x,y,CELL_W,CELL_H); }
        else if(t===4){ ctx.fillStyle = '#052733'; ctx.fillRect(x,y,CELL_W,CELL_H); }
      }
    }
    // planned path
    if(path && path.length){
      ctx.fillStyle = 'rgba(122,174,255,0.96)';
      for(const p of path){
        const px = p.c*CELL_W + Math.floor(CELL_W*0.18), py = p.r*CELL_H + Math.floor(CELL_H*0.18);
        ctx.fillRect(px, py, Math.max(3, Math.floor(CELL_W*0.64)), Math.max(3, Math.floor(CELL_H*0.64)));
      }
    }
    // obstacles
    for(const ob of obstacles){
      ctx.fillStyle = '#ff6b6b';
      ctx.fillRect(ob.c*CELL_W+2, ob.r*CELL_H+2, Math.max(6, CELL_W-4), Math.max(6, CELL_H-4));
      ctx.fillStyle = '#fff';
      ctx.fillRect(ob.c*CELL_W + Math.floor(CELL_W*0.62), ob.r*CELL_H + Math.floor(CELL_H*0.18), Math.max(2, Math.floor(CELL_W*0.14)), Math.max(2, Math.floor(CELL_H*0.14)));
    }
    // start & goal
    ctx.fillStyle = '#4dd0ff'; ctx.fillRect(start.c*CELL_W+3, start.r*CELL_H+3, Math.max(8,CELL_W-6), Math.max(8,CELL_H-6));
    ctx.fillStyle = '#6ef6c1'; ctx.fillRect(goal.c*CELL_W+3, goal.r*CELL_H+3, Math.max(8,CELL_W-6), Math.max(8,CELL_H-6));
    // vehicle (car)
    drawCar(vehicle.r, vehicle.c);
    // update pills
    tickPill.textContent = 'Tick: ' + tick;
    replanPill.textContent = 'Replans: ' + replans;
    nodesPill.textContent = 'Nodes: ' + nodesLast;
  }

  function drawCar(r,c){
    const cx = c*CELL_W + CELL_W/2, cy = r*CELL_H + CELL_H/2;
    let angle = 0;
    if(path && path.length && stepIndex>1){
      const prev = path[Math.max(0, stepIndex-2)];
      const curp = path[Math.min(stepIndex-1, path.length-1)];
      if(prev && curp){ const dr = curp.r - prev.r, dc = curp.c - prev.c; angle = Math.atan2(dr, dc); }
    }
    ctx.save(); ctx.translate(cx, cy); ctx.rotate(angle);
    const w = Math.max(10, Math.min(CELL_W, CELL_H)*0.9), h = Math.max(6, Math.min(CELL_W, CELL_H)*0.5);
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.28)'; ctx.fillRect(-w/2+2, -h/2+6, w-4, h-2);
    // body
    roundRect(ctx, -w/2, -h/2, w, h, Math.max(3, h*0.25)); ctx.fillStyle = '#ffd166'; ctx.fill(); ctx.strokeStyle = 'rgba(0,0,0,0.12)'; ctx.stroke();
    // roof
    roundRect(ctx, -w*0.22, -h*0.8, w*0.44, h*0.9, 2); ctx.fillStyle = '#ff7b7b'; ctx.fill();
    // windows
    ctx.fillStyle = 'rgba(255,255,255,0.12)'; ctx.fillRect(-w*0.12, -h*0.6, w*0.24, h*0.5);
    // wheels
    ctx.fillStyle = '#0a0a0a';
    const ww = Math.max(3, h*0.25);
    ctx.fillRect(-w*0.4, -h*0.55, ww, ww); ctx.fillRect(w*0.2, -h*0.55, ww, ww);
    ctx.fillRect(-w*0.4, h*0.25, ww, ww); ctx.fillRect(w*0.2, h*0.25, ww, ww);
    ctx.restore();
  }

  function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

  // Simulation
  function tickOnce(){
    tick++;
    // move obstacles
    for(const o of obstacles) o.step();
    updateGridWithObstacles();

    if(vehicle.r === goal.r && vehicle.c === goal.c){
      draw();
      return;
    }

    let needReplan = false;
    if(!path || path.length===0) needReplan = true;
    else if(stepIndex >= path.length) needReplan = true;
    else {
      const next = path[stepIndex];
      if(!inBounds(next.r,next.c) || grid[next.r][next.c] !== 0) needReplan = true;
    }

    if(needReplan){
      const res = aStar({r:vehicle.r,c:vehicle.c},{r:goal.r,c:goal.c}, grid);
      lastTime = res.time; nodesLast = res.nodes;
      if(res.path){ path = res.path; replans++; stepIndex = 1; }
      else { path = null; } // do not increment replans if no path
    }

    if(path && path.length>1 && stepIndex < path.length){
      const next = path[stepIndex];
      if(grid[next.r][next.c] === 0){
        vehicle.r = next.r; vehicle.c = next.c; stepIndex++;
      } else {
        path = null; // force replan next tick
      }
    }

    draw();
  }

  function runLoop(){
    if(!running) return;
    tickOnce();
    const v = parseInt(speedRange.value);
    const ms = Math.max(20, Math.round(380 - (v/30)*360));
    timer = setTimeout(runLoop, ms);
  }

  // UI events
  canvas.addEventListener('contextmenu', e=>e.preventDefault());
  canvas.addEventListener('pointerdown', e=>{
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    const c = Math.floor(x / CELL_W), r = Math.floor(y / CELL_H);
    if(!inBounds(r,c)) return;
    if(e.button === 0){ // left -> start
      if(baseGrid[r][c]===0 || baseGrid[r][c]===3 || baseGrid[r][c]===4){
        start = {r,c}; vehicle = {r,c};
        updateGridWithObstacles();
        const res = aStar({r:vehicle.r,c:vehicle.c},{r:goal.r,c:goal.c}, grid);
        if(res.path){ path = res.path; nodesLast = res.nodes; lastTime = res.time; replans++; stepIndex=1; } else { path=null; }
        draw();
      }
    } else if(e.button === 2){ // right -> goal
      if(baseGrid[r][c]===0 || baseGrid[r][c]===3 || baseGrid[r][c]===4){
        goal = {r,c};
        updateGridWithObstacles();
        const res = aStar({r:vehicle.r,c:vehicle.c},{r:goal.r,c:goal.c}, grid);
        if(res.path){ path = res.path; nodesLast = res.nodes; lastTime = res.time; replans++; stepIndex=1; } else { path=null; }
        draw();
      }
    }
  });

  startBtn.addEventListener('click', ()=>{ if(!running){ running=true; runLoop(); } });
  pauseBtn.addEventListener('click', ()=>{ running=false; if(timer) clearTimeout(timer); });
  stepBtn.addEventListener('click', ()=>{ tickOnce(); });
  regenBtn.addEventListener('click', ()=>{ init(); });

  // initialization helpers
  function init(){
    CELL_W = Math.floor(CANVAS_W / COLS); CELL_H = Math.floor(CANVAS_H / ROWS);
    tick = 0; replans = 0; nodesLast = 0; lastTime = 0; stepIndex = 1; path = null;
    generateCity();
    // pick start/goal automatically on roads
    const free=[]; for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(baseGrid[r][c]===0) free.push([r,c]);
    shuffle(free);
    if(free.length >= 2){ start = {r: free[0][0], c: free[0][1]}; goal = {r: free[free.length-1][0], c: free[free.length-1][1]}; vehicle = {r:start.r,c:start.c}; }
    else { start={r:0,c:0}; goal={r:ROWS-1,c:COLS-1}; vehicle={r:0,c:0}; }
    placeObstacles(parseInt(obsCount.value));
    updateGridWithObstacles();
    const res = aStar({r:vehicle.r,c:vehicle.c},{r:goal.r,c:goal.c}, grid);
    if(res.path){ path = res.path; nodesLast=res.nodes; lastTime=res.time; replans++; stepIndex=1; }
    drawOverlay();
    draw();
  }

  // wire speed change to immediate effect
  speedRange.addEventListener('input', ()=>{ if(running){ if(timer) clearTimeout(timer); runLoop(); } });

  // startup
  init();

  // expose for debugging if needed
  window.__cityPlanner = { init, aStar, getState: ()=>({tick,replans,path,vehicle}) };

})();
</script>
</body>
</html>
