<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autonomous Path Planning (Dijkstra)</title>
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #f0f2f5;
            margin: 0;
            padding: 20px;
        }
        h1 {
            color: #333;
            text-align: center;
        }
        p {
            color: #555;
            font-size: 1.1em;
            text-align: center;
        }
        .controls {
            margin-bottom: 20px;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 20px;
            margin: 5px;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #aaa;
            cursor: not-allowed;
        }
        #clearWallsBtn {
            background-color: #dc3545;
        }
        #clearWallsBtn:hover {
            background-color: #a71d2a;
        }
        #randomWallsBtn {
            background-color: #28a745;
        }
        #randomWallsBtn:hover {
            background-color: #1e7e34;
        }
        /* Style for the new button */
        #dynamicEnvBtn {
            background-color: #ffc107;
            color: #333;
        }
        #dynamicEnvBtn:hover {
            background-color: #e0a800;
        }
        canvas {
            border: 2px solid #333;
            background-color: #ffffff;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>

    <h1>Autonomous Vehicle Path Planning</h1>
    <p>Using <strong>Dijkstra's Algorithm</strong> in a Dynamic Environment</p>

    <div class="controls">
        <button id="findPathBtn">Find Path (Dijkstra)</button>
        <button id="clearPathBtn">Clear Path</button>
        <button id="clearWallsBtn">Clear Walls</button>
        <button id="randomWallsBtn">Random Walls</button>
        <button id="dynamicEnvBtn">Start Dynamic Environment</button>
    </div>

    <p><strong>Instructions:</strong> Click and drag to draw walls, or start the dynamic environment.</p>

    <canvas id="pathfindingCanvas"></canvas>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- 1. Setup & Configuration ---
            
            const canvas = document.getElementById('pathfindingCanvas');
            const ctx = canvas.getContext('2d');

            const CELL_SIZE = 20;
            const GRID_WIDTH = 40;
            const GRID_HEIGHT = 25;

            canvas.width = GRID_WIDTH * CELL_SIZE;
            canvas.height = GRID_HEIGHT * CELL_SIZE;

            // Colors
            const COLOR_EMPTY = '#fff';
            const COLOR_WALL = '#333';
            const COLOR_START = '#00e676';
            const COLOR_END = '#ff3d00';
            const COLOR_VISITED = '#80deea';
            const COLOR_PATH = '#ffea00';
            const COLOR_GRID = '#eee';

            let grid = [];
            let startNode = null;
            let endNode = null;
            let isDrawing = false;
            let isAnimating = false;
            
            // --- NEW ---
            let dynamicIntervalId = null; // Stores the ID of our 2-second timer
            // --- END NEW ---

            // --- 2. Node & Grid Initialization ---

            class Node {
                constructor(x, y) {
                    this.x = x; 
                    this.y = y;
                    this.isWall = false;
                    this.distance = Infinity;
                    this.visited = false;
                    this.previousNode = null;
                }

                draw(color) {
                    ctx.fillStyle = color;
                    ctx.fillRect(this.x * CELL_SIZE, this.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    ctx.strokeStyle = COLOR_GRID;
                    ctx.strokeRect(this.x * CELL_SIZE, this.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }

                reset() {
                    this.distance = Infinity;
                    this.visited = false;
                    this.previousNode = null;
                }
            }

            function initializeGrid() {
                grid = [];
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    const row = [];
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        row.push(new Node(x, y));
                    }
                    grid.push(row);
                }
                
                startNode = grid[Math.floor(GRID_HEIGHT / 2)][Math.floor(GRID_WIDTH / 4)];
                endNode = grid[Math.floor(GRID_HEIGHT / 2)][Math.floor(GRID_WIDTH * 3 / 4)];

                startNode.isWall = false;
                endNode.isWall = false;
            }

            function drawGrid() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        const node = grid[y][x];
                        let color = COLOR_EMPTY;
                        if (node.isWall) color = COLOR_WALL;
                        node.draw(color);
                    }
                }
                startNode.draw(COLOR_START);
                endNode.draw(COLOR_END);
            }

            // --- 3. Dijkstra's Algorithm Logic ---

            function getNeighbors(node) {
                const neighbors = [];
                const { x, y } = node;
                if (y > 0) neighbors.push(grid[y - 1][x]); 
                if (y < GRID_HEIGHT - 1) neighbors.push(grid[y + 1][x]);
                if (x > 0) neighbors.push(grid[y][x - 1]);
                if (x < GRID_WIDTH - 1) neighbors.push(grid[y][x + 1]);
                return neighbors.filter(neighbor => !neighbor.isWall);
            }

            function dijkstra() {
                clearPath();
                toggleButtons(false);
                isAnimating = true;

                startNode.distance = 0;
                let unvisitedNodes = getAllNodes();
                let visitedNodesInOrder = [];

                function algorithmStep() {
                    if (unvisitedNodes.length === 0) {
                        animateSearch(visitedNodesInOrder);
                        return;
                    }
                    
                    unvisitedNodes.sort((a, b) => a.distance - b.distance);
                    const currentNode = unvisitedNodes.shift();

                    if (currentNode.distance === Infinity) {
                        animateSearch(visitedNodesInOrder);
                        return;
                    }

                    currentNode.visited = true;
                    visitedNodesInOrder.push(currentNode);

                    if (currentNode === endNode) {
                        animateSearch(visitedNodesInOrder);
                        return;
                    }

                    const neighbors = getNeighbors(currentNode);
                    for (const neighbor of neighbors) {
                        if (neighbor.visited) continue;
                        const newDistance = currentNode.distance + 1;
                        if (newDistance < neighbor.distance) {
                            neighbor.distance = newDistance;
                            neighbor.previousNode = currentNode;
                        }
                    }
                    requestAnimationFrame(algorithmStep);
                }
                requestAnimationFrame(algorithmStep);
            }

            function getAllNodes() {
                const nodes = [];
                for (const row of grid) {
                    for (const node of row) {
                        nodes.push(node);
                    }
                }
                return nodes;
            }

            // --- 4. Animation Functions ---

            function animateSearch(visitedNodes) {
                let i = 0;
                const interval = setInterval(() => {
                    if (i === visitedNodes.length) {
                        clearInterval(interval);
                        animateFinalPath();
                        return;
                    }
                    const node = visitedNodes[i];
                    if (node !== startNode && node !== endNode) {
                        node.draw(COLOR_VISITED);
                    }
                    i++;
                }, 10);
            }

            function animateFinalPath() {
                const path = [];
                let currentNode = endNode;
                while (currentNode !== null) {
                    path.push(currentNode);
                    currentNode = currentNode.previousNode;
                }
                path.reverse();

                let i = 0;
                const interval = setInterval(() => {
                    if (i === path.length) {
                        clearInterval(interval);
                        
                        // --- MODIFIED ---
                        // Only re-enable all buttons if the dynamic env is OFF
                        if (dynamicIntervalId === null) {
                            toggleButtons(true);
                        } else {
                            // Otherwise, just re-enable the "Stop" and "Clear Path"
                            document.getElementById('dynamicEnvBtn').disabled = false;
                            document.getElementById('clearPathBtn').disabled = false;
                        }
                        // --- END MODIFIED ---
                        
                        isAnimating = false;
                        return;
                    }
                    const node = path[i];
                    if (node !== startNode && node !== endNode) {
                        node.draw(COLOR_PATH);
                    }
                    i++;
                }, 40);
            }
            
            // --- 5. Control Button Functions ---
            
            // --- MODIFIED ---
            function toggleButtons(enabled) {
                document.getElementById('findPathBtn').disabled = !enabled;
                document.getElementById('clearPathBtn').disabled = !enabled;
                document.getElementById('clearWallsBtn').disabled = !enabled;
                document.getElementById('randomWallsBtn').disabled = !enabled;

                // The dynamic button is an exception.
                // If the dynamic env is running, it should *always* be enabled
                if (dynamicIntervalId === null) {
                    document.getElementById('dynamicEnvBtn').disabled = !enabled;
                } else {
                    document.getElementById('dynamicEnvBtn').disabled = false;
                }
            }
            // --- END MODIFIED ---

            function clearGrid() {
                if (isAnimating) return;
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        const node = grid[y][x];
                        node.isWall = false;
                        node.reset();
                    }
                }
                drawGrid();
            }

            function clearPath() {
                if (isAnimating) return;
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        grid[y][x].reset();
                    }
                }
                drawGrid();
            }

            function generateRandomWalls() {
                if (isAnimating) return;
                clearGrid();
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        const node = grid[y][x];
                        if (node !== startNode && node !== endNode) {
                            if (Math.random() < 0.3) { // 30% chance
                                node.isWall = true;
                            }
                        }
                    }
                }
                drawGrid();
            }
            
            // --- NEW DYNAMIC ENVIRONMENT FUNCTIONS ---
            
            /**
             * This function is called every 2 seconds by the timer.
             */
            function runDynamicStep() {
                // Don't run if an animation is already in progress
                // It will just wait for the next 2-second cycle
                if (isAnimating) return; 
                
                // 1. Generate new walls
                generateRandomWalls(); 
                
                // 2. Find a new path
                // We add a small delay so the user can see the new walls
                // before the search animation starts.
                setTimeout(() => {
                    if (!isAnimating) {
                       dijkstra();
                    }
                }, 100); 
            }

            /**
             * Starts or stops the 2-second timer.
             */
            function toggleDynamicEnvironment() {
                const btn = document.getElementById('dynamicEnvBtn');
                if (dynamicIntervalId) {
                    // It's ON - turn it OFF
                    clearInterval(dynamicIntervalId);
                    dynamicIntervalId = null;
                    btn.textContent = 'Start Dynamic Environment';
                    btn.style.backgroundColor = '#ffc107'; // Reset color
                    toggleButtons(true); // Re-enable all other buttons
                } else {
                    // It's OFF - turn it ON
                    
                    // Disable other manual controls
                    document.getElementById('findPathBtn').disabled = true;
                    document.getElementById('clearWallsBtn').disabled = true;
                    document.getElementById('randomWallsBtn').disabled = true;
                    btn.textContent = 'Stop Dynamic Environment';
                    btn.style.backgroundColor = '#fd7e14'; // "Stop" color

                    runDynamicStep(); // Run the first step immediately
                    dynamicIntervalId = setInterval(runDynamicStep, 2000); // Run every 2 sec
                }
            }
            // --- END NEW ---

            // --- 6. Event Listeners ---

            function getMousePos(evt) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: evt.clientX - rect.left,
                    y: evt.clientY - rect.top
                };
            }

            function handleMouseInteraction(evt) {
                if (isAnimating || dynamicIntervalId) return; // Don't draw if dynamic
                const { x, y } = getMousePos(evt);
                const col = Math.floor(x / CELL_SIZE);
                const row = Math.floor(y / CELL_SIZE);

                if (row >= 0 && row < GRID_HEIGHT && col >= 0 && col < GRID_WIDTH) {
                    const node = grid[row][col];
                    if (node !== startNode && node !== endNode) {
                        node.isWall = true;
                        node.draw(COLOR_WALL);
                    }
                }
            }

            canvas.addEventListener('mousedown', (e) => {
                if (isAnimating || dynamicIntervalId) return;
                isDrawing = true;
                handleMouseInteraction(e);
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDrawing || isAnimating || dynamicIntervalId) return;
                handleMouseInteraction(e);
            });

            canvas.addEventListener('mouseup', () => {
                isDrawing = false;
            });
            
            canvas.addEventListener('mouseleave', () => {
                isDrawing = false;
            });

            // Button listeners
            document.getElementById('findPathBtn').addEventListener('click', dijkstra);
            document.getElementById('clearWallsBtn').addEventListener('click', clearGrid);
            document.getElementById('clearPathBtn').addEventListener('click', clearPath);
            document.getElementById('randomWallsBtn').addEventListener('click', generateRandomWalls);
            
            // --- NEW ---
            document.getElementById('dynamicEnvBtn').addEventListener('click', toggleDynamicEnvironment);
            // --- END NEW ---

            // --- 7. Initial Run ---
            
            initializeGrid();
            drawGrid();

        });
    </script>

</body>
</html>
