<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Urban Path Intelligence | A* Algorithm with Dynamic Replanning</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg-primary: #0a0a0a;
    --bg-secondary: #111111;
    --bg-card: #1a1a1a;
    --text-primary: #ffffff;
    --text-secondary: #b0b0b0;
    --accent-gold: #c9a96e;
    --accent-silver: #e8e8e8;
    --road: #2a2a2a;
    --building: #1e1e1e;
    --park: #1a3a2a;
    --water: #1a2a3a;
    --car-body: #c9a96e;
    --car-top: #a08554;
    --path: #4a7bac;
    --obstacle: #ac4a4a;
  }

  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  html, body {
    height: 100%;
    font-family: 'Inter', sans-serif;
    background-color: var(--bg-primary);
    color: var(--text-primary);
    scroll-behavior: smooth;
  }

  .header {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    padding: 20px 40px;
    background: rgba(10, 10, 10, 0.95);
    backdrop-filter: blur(10px);
    z-index: 1000;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid rgba(201, 169, 110, 0.2);
  }

  .logo {
    font-size: 24px;
    font-weight: 300;
    letter-spacing: 2px;
    color: var(--accent-gold);
  }

  .nav-links {
    display: flex;
    gap: 30px;
  }

  .nav-links a {
    color: var(--text-secondary);
    text-decoration: none;
    font-weight: 400;
    font-size: 14px;
    transition: color 0.3s;
  }

  .nav-links a:hover {
    color: var(--accent-gold);
  }

  .hero {
    height: 100vh;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    padding: 0 20px;
    position: relative;
    overflow: hidden;
  }

  .hero::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle at center, rgba(201, 169, 110, 0.05) 0%, transparent 70%);
    z-index: -1;
  }

  .hero h1 {
    font-size: 48px;
    font-weight: 300;
    margin-bottom: 20px;
    letter-spacing: 1px;
  }

  .hero p {
    font-size: 18px;
    color: var(--text-secondary);
    max-width: 600px;
    margin-bottom: 40px;
    line-height: 1.6;
  }

  .scroll-indicator {
    position: absolute;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    color: var(--text-secondary);
    font-size: 14px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
  }

  .scroll-indicator::after {
    content: '';
    width: 1px;
    height: 40px;
    background: var(--text-secondary);
    animation: scrollPulse 2s infinite;
  }

  @keyframes scrollPulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  .demo-section {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 100px 20px;
    background: var(--bg-secondary);
  }

  .section-title {
    font-size: 32px;
    font-weight: 300;
    margin-bottom: 60px;
    text-align: center;
    color: var(--accent-gold);
    letter-spacing: 1px;
  }

  .demo-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 30px;
    max-width: 1200px;
    width: 100%;
  }

  .canvas-card {
    background: var(--bg-card);
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.05);
  }

  canvas {
    display: block;
    background: #0f0f0f;
  }

  .controls {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    width: 100%;
    max-width: 800px;
  }

  button {
    background: transparent;
    color: var(--text-secondary);
    border: 1px solid rgba(255, 255, 255, 0.1);
    padding: 12px 20px;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
    font-size: 14px;
    transition: all 0.3s;
    min-width: 120px;
  }

  button:hover {
    border-color: var(--accent-gold);
    color: var(--accent-gold);
  }

  button.primary {
    background: var(--accent-gold);
    color: var(--bg-primary);
    border: none;
  }

  button.primary:hover {
    background: #b89a5f;
  }

  .control-group {
    display: flex;
    gap: 10px;
    align-items: center;
    color: var(--text-secondary);
    font-size: 14px;
  }

  input[type=range] {
    width: 120px;
  }

  select {
    background: transparent;
    color: var(--text-secondary);
    border: 1px solid rgba(255, 255, 255, 0.1);
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 14px;
  }

  .stats {
    display: flex;
    gap: 30px;
    color: var(--text-secondary);
    font-size: 14px;
    margin-top: 20px;
  }

  .legend {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
    justify-content: center;
    margin-top: 20px;
  }

  .legend-item {
    display: flex;
    gap: 8px;
    align-items: center;
    color: var(--text-secondary);
    font-size: 14px;
  }

  .swatch {
    width: 16px;
    height: 16px;
    border-radius: 2px;
  }

  .info-section {
    padding: 100px 40px;
    background: var(--bg-primary);
  }

  .info-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 40px;
    max-width: 1200px;
    margin: 0 auto;
  }

  .info-card {
    background: var(--bg-card);
    padding: 40px;
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.05);
  }

  .info-card h3 {
    font-size: 22px;
    font-weight: 400;
    margin-bottom: 20px;
    color: var(--accent-gold);
  }

  .info-card p {
    color: var(--text-secondary);
    line-height: 1.6;
    margin-bottom: 15px;
  }

  .info-card ul {
    color: var(--text-secondary);
    padding-left: 20px;
    line-height: 1.6;
  }

  .info-card li {
    margin-bottom: 10px;
  }

  .footer {
    padding: 40px;
    text-align: center;
    background: var(--bg-secondary);
    color: var(--text-secondary);
    font-size: 14px;
    border-top: 1px solid rgba(255, 255, 255, 0.05);
  }

  @media (max-width: 768px) {
    .header {
      padding: 15px 20px;
    }
    
    .nav-links {
      display: none;
    }
    
    .hero h1 {
      font-size: 36px;
    }
    
    .info-section {
      padding: 60px 20px;
    }
    
    .info-card {
      padding: 30px;
    }
  }
</style>
</head>
<body>
  <header class="header">
    <div class="logo">URBAN PATH INTELLIGENCE</div>
    <nav class="nav-links">
      <a href="#demo">Demo</a>
      <a href="#algorithm">Algorithm</a>
      <a href="#applications">Applications</a>
      <a href="#about">About</a>
    </nav>
  </header>

  <section class="hero">
    <h1>Precision Pathfinding for Modern Urban Mobility</h1>
    <p>An advanced implementation of the A* search algorithm with dynamic replanning capabilities, designed for complex urban environments with moving obstacles.</p>
    <div class="scroll-indicator">Scroll to explore</div>
  </section>

  <section class="demo-section" id="demo">
    <h2 class="section-title">Interactive Path Planning Demo</h2>
    <div class="demo-container">
      <div class="canvas-card">
        <canvas id="gridCanvas" width="800" height="500"></canvas>
      </div>
      
      <div class="controls">
        <button id="startBtn" class="primary">Start Navigation</button>
        <button id="pauseBtn">Pause</button>
        <button id="stepBtn">Single Step</button>
        <button id="resetBtn">Reset</button>
        <button id="regenBtn">New City</button>
        
        <div class="control-group">
          <label>Speed</label>
          <input type="range" id="speedRange" min="1" max="30" value="10" />
        </div>
        
        <div class="control-group">
          <label>Obstacles</label>
          <select id="obsCount">
            <option value="4">4</option>
            <option value="8" selected>8</option>
            <option value="12">12</option>
            <option value="18">18</option>
          </select>
        </div>
        
        <div class="control-group">
          <label>Grid</label>
          <input id="inputCols" type="number" value="30" min="12" max="80" style="width:60px;padding:6px;background:transparent;color:var(--text-secondary);border:1px solid rgba(255,255,255,0.1);border-radius:4px;"/>
          <span>Ã—</span>
          <input id="inputRows" type="number" value="20" min="8" max="60" style="width:60px;padding:6px;background:transparent;color:var(--text-secondary);border:1px solid rgba(255,255,255,0.1);border-radius:4px;"/>
          <button id="applyGrid" style="padding:6px 12px;">Apply</button>
        </div>
      </div>
      
      <div class="stats">
        <div>Tick: <span id="tick">0</span></div>
        <div>Replans: <span id="replans">0</span></div>
        <div>Path Length: <span id="pathLength">0</span></div>
        <div>Last Plan: <span id="lastPlanTime">0.000s</span></div>
      </div>
      
      <div class="legend">
        <div class="legend-item"><span class="swatch" style="background:var(--road)"></span> Road</div>
        <div class="legend-item"><span class="swatch" style="background:var(--building)"></span> Building</div>
        <div class="legend-item"><span class="swatch" style="background:var(--park)"></span> Park</div>
        <div class="legend-item"><span class="swatch" style="background:var(--water)"></span> Water</div>
        <div class="legend-item"><span class="swatch" style="background:var(--obstacle)"></span> Moving Obstacle</div>
        <div class="legend-item"><span class="swatch" style="background:var(--path)"></span> Planned Path</div>
        <div class="legend-item">
          <canvas id="miniCar" width="42" height="18" style="border-radius:4px;background:transparent"></canvas>
          <span>Vehicle</span>
        </div>
      </div>
      
      <div style="margin-top:20px; text-align:center; color:var(--text-secondary); font-size:14px;">
        <p>Tip: Left-click to set start position, Right-click to set destination. Regenerate city for a new layout.</p>
      </div>
    </div>
  </section>

  <section class="info-section" id="algorithm">
    <h2 class="section-title">The A* Algorithm & Dynamic Replanning</h2>
    <div class="info-grid">
      <div class="info-card">
        <h3>A* Search Algorithm</h3>
        <p>The A* (A-star) algorithm is an informed search algorithm that finds the shortest path between two points. It combines the advantages of Dijkstra's algorithm and greedy best-first search.</p>
        <p>Key components:</p>
        <ul>
          <li><strong>Heuristic Function</strong>: Estimates cost from current node to goal</li>
          <li><strong>Cost Function</strong>: Actual cost from start to current node</li>
          <li><strong>Priority Queue</strong>: Always expands the most promising node first</li>
        </ul>
      </div>
      
      <div class="info-card">
        <h3>Dynamic Replanning</h3>
        <p>In dynamic environments where obstacles can move, static path planning is insufficient. Our implementation includes:</p>
        <ul>
          <li>Continuous monitoring of the planned path</li>
          <li>Automatic replanning when obstacles block the path</li>
          <li>Efficient incremental search from current position</li>
          <li>Minimal disruption to ongoing navigation</li>
        </ul>
      </div>
      
      <div class="info-card">
        <h3>Urban Environment Simulation</h3>
        <p>Our city generator creates realistic urban layouts with:</p>
        <ul>
          <li>Road networks with intersections</li>
          <li>Building blocks of varying sizes</li>
          <li>Green spaces and water features</li>
          <li>Moving obstacles that follow traffic patterns</li>
        </ul>
        <p>This provides a realistic testbed for autonomous navigation algorithms.</p>
      </div>
    </div>
  </section>

  <section class="info-section" id="applications" style="background:var(--bg-secondary);">
    <h2 class="section-title">Real-World Applications</h2>
    <div class="info-grid">
      <div class="info-card">
        <h3>Autonomous Vehicles</h3>
        <p>Dynamic path planning is crucial for self-driving cars navigating complex urban environments with pedestrians, other vehicles, and changing road conditions.</p>
      </div>
      
      <div class="info-card">
        <h3>Delivery & Logistics</h3>
        <p>Optimized routing with real-time obstacle avoidance enables efficient last-mile delivery in dense urban areas.</p>
      </div>
      
      <div class="info-card">
        <h3>Emergency Services</h3>
        <p>First responders benefit from dynamic replanning that adapts to road closures, traffic, and other unexpected obstacles.</p>
      </div>
      
      <div class="info-card">
        <h3>Urban Planning</h3>
        <p>Simulation of traffic flow and navigation patterns helps city planners design more efficient transportation networks.</p>
      </div>
    </div>
  </section>

  <section class="info-section" id="about">
    <h2 class="section-title">Technical Implementation</h2>
    <div class="info-grid">
      <div class="info-card">
        <h3>Algorithm Details</h3>
        <p>Our implementation uses Manhattan distance as the heuristic function, which is optimal for grid-based movement without diagonals.</p>
        <p>The algorithm maintains:</p>
        <ul>
          <li>Open set: Nodes to be evaluated</li>
          <li>Closed set: Already evaluated nodes</li>
          <li>Cost maps: g(n) and f(n) values for each node</li>
        </ul>
      </div>
      
      <div class="info-card">
        <h3>Performance Metrics</h3>
        <p>Key metrics tracked during simulation:</p>
        <ul>
          <li>Path length: Number of steps to destination</li>
          <li>Replanning count: How often new paths are calculated</li>
          <li>Nodes expanded: Computational complexity indicator</li>
          <li>Planning time: Algorithm execution speed</li>
        </ul>
      </div>
      
      <div class="info-card">
        <h3>Future Enhancements</h3>
        <p>Potential improvements to the system:</p>
        <ul>
          <li>Integration of D* Lite for more efficient replanning</li>
          <li>Vehicle kinematics with turning radius constraints</li>
          <li>Multi-agent path planning with collision avoidance</li>
          <li>Machine learning for predictive obstacle movement</li>
        </ul>
      </div>
    </div>
  </section>

  <footer class="footer">
    <p>Urban Path Intelligence | Advanced Path Planning Research</p>
    <p style="margin-top:10px;font-size:12px;">Design inspired by Rolls-Royce aesthetic principles</p>
  </footer>

<script>
// All the JavaScript code from the original implementation goes here
// I've kept it exactly the same, just updating the canvas size reference

/* ----------------- Config/State ----------------- */
const canvas = document.getElementById('gridCanvas');
const ctx = canvas.getContext('2d');
const miniCar = document.getElementById('miniCar').getContext('2d');
const tickSpan = document.getElementById('tick');
const replanSpan = document.getElementById('replans');
const pathLengthSpan = document.getElementById('pathLength');
const lastPlanTimeSpan = document.getElementById('lastPlanTime');

const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const stepBtn = document.getElementById('stepBtn');
const resetBtn = document.getElementById('resetBtn');
const regenBtn = document.getElementById('regenBtn');
const obsCountSelect = document.getElementById('obsCount');
const speedRange = document.getElementById('speedRange');
const inputCols = document.getElementById('inputCols');
const inputRows = document.getElementById('inputRows');
const applyGrid = document.getElementById('applyGrid');

const CANVAS_W = canvas.width, CANVAS_H = canvas.height;

let COLS = parseInt(inputCols.value) || 30;
let ROWS = parseInt(inputRows.value) || 20;
let CELL_W = Math.floor(CANVAS_W / COLS), CELL_H = Math.floor(CANVAS_H / ROWS);

let baseGrid = []; // 0 road/free, 1 building, 3 park, 4 water
let grid = [];     // baseGrid + dynamic obstacles (2)
let obstacles = []; // moving obstacles on roads
let start = {r:0,c:0}, goal = {r: ROWS-1, c: COLS-1}, vehicle = {r:0,c:0};
let path = [], stepIndex = 1;
let running = false;
let tick = 0, replanCount = 0, nodesExpandedLast = 0, lastPlanTime = 0;
let TICK_INTERVAL_MS = 100;
let animationTimer = null;

/* ----------------- Utility ----------------- */
function randInt(a,b){ return Math.floor(a + Math.random()*(b-a+1)); }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
function inBounds(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS; }

/* ----------------- City Generator ----------------- */
function generateCity(){
  baseGrid = Array.from({length:ROWS}, () => Array.from({length:COLS}, () => 1)); // default building

  // choose road lines: pick offsets with variable spacing
  let hRoads = [0], vRoads = [0];
  // generate horizontal roads
  let pos = randInt(2,4);
  while(pos < ROWS - 2){
    hRoads.push(pos);
    pos += randInt(3,6);
  }
  hRoads.push(ROWS-1);
  // vertical
  pos = randInt(3,6);
  while(pos < COLS - 2){
    vRoads.push(pos);
    pos += randInt(3,7);
  }
  vRoads.push(COLS-1);

  // make the roads thicker (2-3 cells)
  for (const hr of hRoads){
    const thickness = (Math.random()<0.6) ? 2 : 1;
    for (let t=0;t<thickness;t++){
      const r = Math.min(ROWS-1, hr + (t - Math.floor(thickness/2)));
      for (let c=0;c<COLS;c++) baseGrid[r][c] = 0;
    }
  }
  for (const vc of vRoads){
    const thickness = (Math.random()<0.6) ? 2 : 1;
    for (let t=0;t<thickness;t++){
      const c = Math.min(COLS-1, vc + (t - Math.floor(thickness/2)));
      for (let r=0;r<ROWS;r++) baseGrid[r][c] = 0;
    }
  }

  // Mark some building blocks as parks or water
  const blocks = [];
  for (let r=0;r<ROWS;r++){
    for (let c=0;c<COLS;c++){
      if (baseGrid[r][c] === 1) blocks.push([r,c]);
    }
  }
  shuffle(blocks);
  // choose ~6% as parks, 3% as water depending on grid size
  const parkCount = Math.max(1, Math.floor(blocks.length * 0.06));
  const waterCount = Math.max(1, Math.floor(blocks.length * 0.03));
  for (let i=0;i<parkCount;i++){
    const [r,c] = blocks[i];
    baseGrid[r][c] = 3;
  }
  for (let i=parkCount;i<parkCount+waterCount;i++){
    const [r,c] = blocks[i];
    baseGrid[r][c] = 4;
  }

  // carve a few alleyways (random roads in blocks)
  for (let i=0;i<Math.floor((ROWS*COLS)*0.01);i++){
    const r = randInt(1,ROWS-2), c = randInt(1,COLS-2);
    baseGrid[r][c] = 0; // small alley
  }
}

/* ----------------- Obstacles ----------------- */
class Obstacle {
  constructor(r,c, pattern='line'){
    this.r = r; this.c = c; this.pattern = pattern;
    const dirs = [{dr:1,dc:0},{dr:-1,dc:0},{dr:0,dc:1},{dr:0,dc:-1}];
    this.dir = dirs[Math.floor(Math.random()*dirs.length)];
  }
  step(){
    if (this.pattern === 'random'){
      const choices = [{dr:0,dc:0},{dr:1,dc:0},{dr:-1,dc:0},{dr:0,dc:1},{dr:0,dc:-1}];
      const pick = choices[randInt(0,choices.length-1)];
      const nr = this.r + pick.dr, nc = this.c + pick.dc;
      if (inBounds(nr,nc) && baseGrid[nr][nc] === 0 && !(nr===start.r&&nc===start.c) && !(nr===goal.r&&nc===goal.c)) {
        this.r = nr; this.c = nc;
      }
    } else {
      const nr = this.r + this.dir.dr, nc = this.c + this.dir.dc;
      if (!inBounds(nr,nc) || baseGrid[nr][nc] !== 0 || (nr===start.r&&nc===start.c) || (nr===goal.r&&nc===goal.c)) {
        this.dir.dr *= -1; this.dir.dc *= -1;
        const nr2 = this.r + this.dir.dr, nc2 = this.c + this.dir.dc;
        if (inBounds(nr2,nc2) && baseGrid[nr2][nc2] === 0) { this.r = nr2; this.c = nc2; }
      } else { this.r = nr; this.c = nc; }
    }
  }
}

/* ----------------- Grid & A* ----------------- */
function updateGridWithObstacles(){
  grid = baseGrid.map(row => row.slice());
  for (const o of obstacles) {
    if (inBounds(o.r,o.c)) grid[o.r][o.c] = 2; // dynamic obstacle
  }
}

function aStar(startNode, goalNode, gridState) {
  const t0 = performance.now();
  const h = (a,b) => Math.abs(a.r-b.r) + Math.abs(a.c-b.c);
  const neighbors = [{dr:1,dc:0},{dr:-1,dc:0},{dr:0,dc:1},{dr:0,dc:-1}];
  const rows = gridState.length, cols = gridState[0].length;
  const key = n => `${n.r},${n.c}`;

  const open = new TinyPQ((a,b)=>a.f - b.f);
  const gScore = new Map(), fScore = new Map(), came = new Map();
  gScore.set(key(startNode), 0);
  fScore.set(key(startNode), h(startNode, goalNode));
  open.push({node:startNode, f:fScore.get(key(startNode))});
  let nodes = 0;

  while(open.size()){
    const cur = open.pop().node;
    nodes++;
    if (cur.r === goalNode.r && cur.c === goalNode.c){
      // reconstruct
      const p = [];
      let ck = key(cur); p.push(cur);
      while(came.has(ck)){
        const prev = came.get(ck); p.push(prev); ck = key(prev);
      }
      p.reverse();
      const dt = (performance.now() - t0)/1000;
      return {path: p, nodes, time: dt};
    }
    for (const nb of neighbors){
      const nr = cur.r + nb.dr, nc = cur.c + nb.dc;
      if (!inBounds(nr,nc)) continue;
      // only travel on roads (0) or goal/start if they are on non-road is allowed?
      if (gridState[nr][nc] !== 0 && !(nr===goalNode.r && nc===goalNode.c)) continue;
      const neighbor = {r:nr,c:nc};
      const tentative = (gScore.get(key(cur)) ?? 1e9) + 1;
      if (tentative < (gScore.get(key(neighbor)) ?? 1e9)){
        came.set(key(neighbor), cur);
        gScore.set(key(neighbor), tentative);
        const fval = tentative + h(neighbor, goalNode);
        fScore.set(key(neighbor), fval);
        open.push({node:neighbor, f:fval});
      }
    }
  }
  const dt = (performance.now() - t0)/1000;
  return {path:null, nodes, time:dt};
}

// tiny priority queue
function TinyPQ(cmp){ this.data=[]; this.cmp=cmp||((a,b)=>a-b); }
TinyPQ.prototype.size = function(){ return this.data.length; };
TinyPQ.prototype.push = function(val){
  this.data.push(val); let i=this.data.length-1;
  while(i>0){ const p=Math.floor((i-1)/2); if (this.cmp(this.data[i], this.data[p])>=0) break; [this.data[i],this.data[p]]=[this.data[p],this.data[i]]; i=p; }
};
TinyPQ.prototype.pop = function(){
  const top = this.data[0]; const last = this.data.pop();
  if (this.data.length>0){ this.data[0]=last; let i=0; while(true){ const l=2*i+1, r=2*i+2; let s=i; if (l<this.data.length && this.cmp(this.data[l],this.data[s])<0) s=l; if (r<this.data.length && this.cmp(this.data[r],this.data[s])<0) s=r; if (s===i) break; [this.data[i],this.data[s]]=[this.data[s],this.data[i]]; i=s; } }
  return top;
};

/* ----------------- Drawing ----------------- */
function drawMiniCar(){
  const c = miniCar;
  c.clearRect(0,0,42,18);
  // body
  c.fillStyle = '#c9a96e'; c.strokeStyle = '#a08554';
  c.beginPath(); c.roundRect(2,2,30,14,3); c.fill(); c.stroke();
  // roof
  c.fillStyle = '#a08554'; c.beginPath(); c.roundRect(8,1,12,8,2); c.fill();
  // wheels
  c.fillStyle = '#333'; c.fillRect(4,13,6,3); c.fillRect(22,13,6,3);
}
CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){ if (r===undefined) r=4; this.moveTo(x+r,y); this.arcTo(x+w,y,x+w,y+h,r); this.arcTo(x+w,y+h,x,y+h,r); this.arcTo(x,y+h,x,y,r); this.arcTo(x,y,x+w,y,r); this.closePath(); }

/* draw cell types:
 - 0 road (dark)
 - 1 building (tile)
 - 2 dynamic obstacle (moving)
 - 3 park (green)
 - 4 water (blue)
*/
function draw(){
  ctx.clearRect(0,0,CANVAS_W,CANVAS_H);
  CELL_W = Math.floor(CANVAS_W / COLS);
  CELL_H = Math.floor(CANVAS_H / ROWS);

  // draw base grid
  for (let r=0;r<ROWS;r++){
    for (let c=0;c<COLS;c++){
      const x = c*CELL_W, y = r*CELL_H;
      const t = baseGrid[r][c];
      if (t === 0){ // road
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(x,y,CELL_W,CELL_H);
        // lane divider (thin)
        if ((r+c) % 6 === 0){
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(x+Math.floor(CELL_W*0.25), y+Math.floor(CELL_H*0.45), Math.max(1,Math.floor(CELL_W*0.5)), Math.max(1,Math.floor(CELL_H*0.08)));
        }
      } else if (t === 1){ // building
        ctx.fillStyle = '#1e1e1e';
        ctx.fillRect(x,y,CELL_W,CELL_H);
        // windows pattern
        ctx.fillStyle = '#2a2a2a';
        for (let i=0;i<2;i++){
          for (let j=0;j<2;j++){
            const wx = x + 4 + j*(Math.max(6,CELL_W-12)/2);
            const wy = y + 4 + i*(Math.max(6,CELL_H-12)/2);
            ctx.fillRect(wx, wy, Math.max(3,Math.floor(CELL_W*0.2)), Math.max(3,Math.floor(CELL_H*0.18)));
          }
        }
      } else if (t === 3){ // park
        ctx.fillStyle = '#1a3a2a';
        ctx.fillRect(x,y,CELL_W,CELL_H);
        // trees
        if (Math.random() < 0.12){
          ctx.fillStyle = '#2a7a4a';
          ctx.beginPath(); ctx.arc(x+CELL_W*0.3,y+CELL_H*0.3, Math.max(2,Math.min(CELL_W,CELL_H)*0.12),0,Math.PI*2); ctx.fill();
        }
      } else if (t === 4){ // water
        ctx.fillStyle = '#1a2a3a';
        ctx.fillRect(x,y,CELL_W,CELL_H);
        // ripple
        ctx.fillStyle = '#2a3a4a';
        ctx.fillRect(x+2,y+2,Math.max(3,CELL_W-4),Math.max(3,CELL_H-4));
      }
    }
  }

  // path draw (slightly offset squares)
  if (path && path.length){
    ctx.fillStyle = 'rgba(74, 123, 172, 0.9)';
    for (const p of path){
      const px = p.c*CELL_W + Math.floor(CELL_W*0.18);
      const py = p.r*CELL_H + Math.floor(CELL_H*0.18);
      ctx.fillRect(px, py, Math.max(3,Math.floor(CELL_W*0.64)), Math.max(3,Math.floor(CELL_H*0.64)));
    }
  }

  // obstacles
  for (const ob of obstacles){
    const x = ob.c*CELL_W, y = ob.r*CELL_H;
    ctx.fillStyle = '#ac4a4a';
    ctx.fillRect(x+2,y+2, Math.max(6,CELL_W-4), Math.max(6,CELL_H-4));
    // small indicator
    ctx.fillStyle = '#fff';
    ctx.fillRect(x + Math.floor(CELL_W*0.6), y + Math.floor(CELL_H*0.18), Math.max(2,Math.floor(CELL_W*0.14)), Math.max(2,Math.floor(CELL_H*0.14)));
  }

  // start & goal
  ctx.fillStyle = '#c9a96e';
  ctx.fillRect(start.c*CELL_W+3, start.r*CELL_H+3, Math.max(8,CELL_W-6), Math.max(8,CELL_H-6));
  ctx.fillStyle = '#d9b97e';
  ctx.fillRect(goal.c*CELL_W+3, goal.r*CELL_H+3, Math.max(8,CELL_W-6), Math.max(8,CELL_H-6));

  // vehicle (draw car rotated by direction)
  drawCar(vehicle.r, vehicle.c);

  // update stats
  tickSpan.textContent = tick;
  replanSpan.textContent = replanCount;
  pathLengthSpan.textContent = path ? path.length : 0;
  lastPlanTimeSpan.textContent = lastPlanTime.toFixed(3) + 's';
}

function drawCar(r,c){
  const cx = c*CELL_W + CELL_W/2;
  const cy = r*CELL_H + CELL_H/2;
  // compute orientation using previous step if possible
  let angle = 0;
  if (path && path.length && stepIndex > 1){
    const prev = path[Math.max(0, stepIndex-2)];
    if (prev){
      const dr = (path[Math.min(stepIndex-1, path.length-1)].r - prev.r);
      const dc = (path[Math.min(stepIndex-1, path.length-1)].c - prev.c);
      angle = Math.atan2(dr, dc); // note: y axis downward
    }
  }
  // draw rotated car
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(angle);
  // body
  const w = Math.max(10, Math.min(CELL_W, CELL_H) * 0.9);
  const h = Math.max(6, Math.min(CELL_W, CELL_H) * 0.5);
  // shadow
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.fillRect(-w/2+2, -h/2+6, w-4, h-2);
  // main body
  ctx.fillStyle = '#c9a96e';
  roundRect(ctx, -w/2, -h/2, w, h, Math.max(3, h*0.25));
  ctx.fill();
  ctx.strokeStyle = 'rgba(0,0,0,0.15)';
  ctx.stroke();
  // top/roof
  ctx.fillStyle = '#a08554';
  roundRect(ctx, -w*0.22, -h*0.8, w*0.44, h*0.9, 2);
  ctx.fill();
  // windows (glass)
  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  ctx.fillRect(-w*0.12, -h*0.6, w*0.24, h*0.5);
  // wheels
  ctx.fillStyle = '#222';
  const wheelW = Math.max(3, h*0.25);
  ctx.fillRect(-w*0.4, -h*0.55, wheelW, wheelW);
  ctx.fillRect(w*0.2, -h*0.55, wheelW, wheelW);
  ctx.fillRect(-w*0.4, h*0.25, wheelW, wheelW);
  ctx.fillRect(w*0.2, h*0.25, wheelW, wheelW);
  ctx.restore();
}
function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

/* ----------------- Simulation Loop ----------------- */
function tickOnce(){
  tick++;
  // move obstacles
  for (const o of obstacles) o.step();
  updateGridWithObstacles();

  // if vehicle reached goal, stop moving but still let obstacles move so you can see scenic
  if (vehicle.r === goal.r && vehicle.c === goal.c){
    draw();
    return;
  }

  // check replanning
  let needReplan = false;
  if (!path || path.length === 0) needReplan = true;
  else if (stepIndex >= path.length) needReplan = true;
  else {
    const next = path[stepIndex];
    if (!inBounds(next.r,next.c) || grid[next.r][next.c] !== 0) needReplan = true;
  }

  if (needReplan){
    const res = aStar({r:vehicle.r,c:vehicle.c},{r:goal.r,c:goal.c},grid);
    lastPlanTime = res.time;
    nodesExpandedLast = res.nodes;
    path = res.path;
    replanCount++;
    stepIndex = 1;
  }

  // move one step
  if (path && path.length > 1 && stepIndex < path.length){
    vehicle.r = path[stepIndex].r;
    vehicle.c = path[stepIndex].c;
    stepIndex++;
  }

  // collision check
  if (grid[vehicle.r][vehicle.c] !== 0 && !(vehicle.r===goal.r && vehicle.c===goal.c)){
    console.error('Collision at', vehicle);
    running = false;
  }
  draw();
}

/* animation */
function runLoop(){
  if (!running) return;
  tickOnce();
  animationTimer = setTimeout(runLoop, TICK_INTERVAL_MS);
}

/* ----------------- UI & Events ----------------- */
startBtn.addEventListener('click', ()=>{
  if (!running){ running = true; runLoop(); }
});
pauseBtn.addEventListener('click', ()=>{
  running = false; if (animationTimer) clearTimeout(animationTimer);
});
stepBtn.addEventListener('click', ()=>{ tickOnce(); });
resetBtn.addEventListener('click', ()=>{ init(); });
regenBtn.addEventListener('click', ()=>{ regenerateCityAndReset(); });

speedRange.addEventListener('input', ()=>{
  const v = parseInt(speedRange.value);
  TICK_INTERVAL_MS = Math.max(20, Math.round(380 - (v/30)*360));
});

canvas.addEventListener('contextmenu', e => e.preventDefault());
canvas.addEventListener('pointerdown', e => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left, y = e.clientY - rect.top;
  const c = Math.floor(x / CELL_W), r = Math.floor(y / CELL_H);
  if (!inBounds(r,c)) return;
  if (e.button === 0){ // left click -> start
    if (baseGrid[r][c] === 0 || baseGrid[r][c] === 3 || baseGrid[r][c] === 4){
      start = {r,c}; vehicle = {r,c};
      updateGridWithObstacles();
      const res = aStar({r:vehicle.r,c:vehicle.c},{r:goal.r,c:goal.c},grid);
      path = res.path; nodesExpandedLast=res.nodes; lastPlanTime=res.time; replanCount++;
      stepIndex = 1;
      draw();
    }
  } else if (e.button === 2){ // right click -> goal
    if (baseGrid[r][c] === 0 || baseGrid[r][c] === 3 || baseGrid[r][c] === 4){
      goal = {r,c};
      updateGridWithObstacles();
      const res = aStar({r:vehicle.r,c:vehicle.c},{r:goal.r,c:goal.c},grid);
      path = res.path; nodesExpandedLast=res.nodes; lastPlanTime=res.time; replanCount++;
      stepIndex = 1;
      draw();
    }
  }
});

applyGrid.addEventListener('click', ()=>{
  const newCols = Math.max(12, Math.min(80, parseInt(inputCols.value)||COLS));
  const newRows = Math.max(8, Math.min(60, parseInt(inputRows.value)||ROWS));
  COLS = newCols; ROWS = newRows;
  CELL_W = Math.floor(CANVAS_W / COLS); CELL_H = Math.floor(CANVAS_H / ROWS);
  start = {r:0,c:0}; goal = {r:ROWS-1,c:COLS-1}; vehicle = {r:0,c:0};
  init();
});

/* ----------------- Setup helpers ----------------- */
function buildObstacles(n){
  obstacles = [];
  const free = [];
  for (let r=0;r<ROWS;r++){
    for (let c=0;c<COLS;c++){
      if (baseGrid[r][c] === 0 && !(r===start.r&&c===start.c) && !(r===goal.r&&c===goal.c)){
        free.push({r,c});
      }
    }
  }
  shuffle(free);
  for (let i=0;i<n && i<free.length;i++){
    const p = free[i];
    const pattern = (i%2===0)?'line':'random';
    obstacles.push(new Obstacle(p.r,p.c,pattern));
  }
}

/* regenerate city and reset vehicle */
function regenerateCityAndReset(){
  running = false; if (animationTimer) clearTimeout(animationTimer);
  generateCity();
  start = {r:0,c:0}; goal = {r:ROWS-1,c:COLS-1}; vehicle = {r:0,c:0};
  const n = parseInt(obsCountSelect.value);
  buildObstacles(n);
  updateGridWithObstacles();
  const res = aStar({r:vehicle.r,c:vehicle.c},{r:goal.r,c:goal.c},grid);
  path = res.path; nodesExpandedLast=res.nodes; lastPlanTime=res.time;
  replanCount = 1; stepIndex = 1; tick = 0;
  draw();
}

/* init */
function init(){
  tick = 0; replanCount = 0; nodesExpandedLast = 0; lastPlanTime = 0; stepIndex = 1; path = [];
  generateCity();
  start = {r:0,c:0}; goal = {r:ROWS-1,c:COLS-1}; vehicle = {r:0,c:0};
  const n = parseInt(obsCountSelect.value);
  buildObstacles(n);
  updateGridWithObstacles();
  const res = aStar({r:vehicle.r,c:vehicle.c},{r:goal.r,c:goal.c},grid);
  path = res.path; nodesExpandedLast=res.nodes; lastPlanTime=res.time;
  replanCount++;
  draw();
  drawMiniCar();
}

/* startup */
TICK_INTERVAL_MS = Math.max(20, Math.round(380 - (parseInt(speedRange.value)/30)*360));
init();

// expose for debugging
window.__cityplanner = { init, regenerateCityAndReset, aStar, getState: ()=>({tick,replanCount,path,vehicle}) };
</script>
</body>
</html>
