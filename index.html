<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autonomous Path Planning (Dijkstra)</title>
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #f0f2f5;
            margin: 0;
            padding: 20px;
        }
        h1 {
            color: #333;
            text-align: center;
        }
        p {
            color: #555;
            font-size: 1.1em;
            text-align: center;
            max-width: 600px;
        }
        .controls {
            margin-bottom: 20px;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 20px;
            margin: 5px;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #aaa;
            cursor: not-allowed;
        }
        #clearWallsBtn {
            background-color: #dc3545;
        }
        #clearWallsBtn:hover {
            background-color: #a71d2a;
        }
        #generateMazeBtn {
            background-color: #28a745;
        }
        #generateMazeBtn:hover {
            background-color: #1e7e34;
        }
        canvas {
            border: 2px solid #333;
            background-color: #ffffff;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>

    <h1>Autonomous Vehicle Path Planning</h1>
    <p>Using <strong>Dijkstra's Algorithm</strong> in a Dynamic Environment</p>

    <div class="controls">
        <button id="findPathBtn">Find Path (Dijkstra)</button>
        <button id="clearPathBtn">Clear Path</button>
        <button id="clearWallsBtn">Clear Walls</button>
        <button id="generateMazeBtn">Generate Maze</button>
    </div>

    <p>
        <strong>Instructions:</strong>
        1. Click "Generate Maze" to create a new maze (this maze has loops).
        2. Click "Find Path" to find the shortest route.
        3. <strong>Click on the yellow path</strong> to add a blockade and force a re-route.
    </p>

    <canvas id="pathfindingCanvas"></canvas>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- 1. Setup & Configuration ---
            
            const canvas = document.getElementById('pathfindingCanvas');
            const ctx = canvas.getContext('2d');

            const CELL_SIZE = 20;
            const GRID_WIDTH = 40;
            const GRID_HEIGHT = 25;

            canvas.width = GRID_WIDTH * CELL_SIZE;
            canvas.height = GRID_HEIGHT * CELL_SIZE;

            const COLOR_EMPTY = '#fff';
            const COLOR_WALL = '#333';
            const COLOR_START = '#00e676';
            const COLOR_END = '#ff3d00';
            const COLOR_VISITED = '#80deea';
            const COLOR_PATH = '#ffea00';
            const COLOR_GRID = '#eee';

            let grid = [];
            let startNode = null;
            let endNode = null;
            let isDrawing = false;
            let isAnimating = false;
            let currentPath = [];

            // --- 2. Node & Grid Initialization ---

            class Node {
                constructor(x, y) {
                    this.x = x; 
                    this.y = y;
                    this.isWall = false;
                    this.distance = Infinity;
                    this.visited = false;
                    this.previousNode = null;
                }

                draw(color) {
                    ctx.fillStyle = color;
                    ctx.fillRect(this.x * CELL_SIZE, this.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    ctx.strokeStyle = COLOR_GRID;
                    ctx.strokeRect(this.x * CELL_SIZE, this.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }

                reset() {
                    this.distance = Infinity;
                    this.visited = false;
                    this.previousNode = null;
                }
            }

            function initializeGrid() {
                grid = [];
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    const row = [];
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        row.push(new Node(x, y));
                    }
                    grid.push(row);
                }
                
                startNode = grid[Math.floor(GRID_HEIGHT / 2)][Math.floor(GRID_WIDTH / 4)];
                endNode = grid[Math.floor(GRID_HEIGHT / 2)][Math.floor(GRID_WIDTH * 3 / 4)];
                startNode.isWall = false;
                endNode.isWall = false;
            }

            function drawGrid() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        const node = grid[y][x];
                        let color = COLOR_EMPTY;
                        if (node.isWall) color = COLOR_WALL;
                        node.draw(color);
                    }
                }
                startNode.draw(COLOR_START);
                endNode.draw(COLOR_END);
            }

            // --- 3. Dijkstra's Algorithm Logic ---

            function getNeighbors(node) {
                const neighbors = [];
                const { x, y } = node;
                if (y > 0) neighbors.push(grid[y - 1][x]); 
                if (y < GRID_HEIGHT - 1) neighbors.push(grid[y + 1][x]);
                if (x > 0) neighbors.push(grid[y][x - 1]);
                if (x < GRID_WIDTH - 1) neighbors.push(grid[y][x + 1]);
                return neighbors.filter(neighbor => !neighbor.isWall);
            }

            function dijkstra() {
                clearPath(); 
                toggleButtons(false);
                isAnimating = true;

                startNode.distance = 0;
                let unvisitedNodes = getAllNodes();
                let visitedNodesInOrder = [];

                function algorithmStep() {
                    if (unvisitedNodes.length === 0) {
                        animateSearch(visitedNodesInOrder);
                        return;
                    }
                    
                    unvisitedNodes.sort((a, b) => a.distance - b.distance);
                    const currentNode = unvisitedNodes.shift();

                    if (currentNode.distance === Infinity) {
                        animateSearch(visitedNodesInOrder);
                        return;
                    }

                    currentNode.visited = true;
                    visitedNodesInOrder.push(currentNode);

                    if (currentNode === endNode) {
                        animateSearch(visitedNodesInOrder);
                        return;
                    }

                    const neighbors = getNeighbors(currentNode);
                    for (const neighbor of neighbors) {
                        if (neighbor.visited) continue;
                        const newDistance = currentNode.distance + 1;
                        if (newDistance < neighbor.distance) {
                            neighbor.distance = newDistance;
                            neighbor.previousNode = currentNode;
                        }
                    }
                    requestAnimationFrame(algorithmStep);
                }
                requestAnimationFrame(algorithmStep);
            }

            function getAllNodes() {
                const nodes = [];
                for (const row of grid) {
                    for (const node of row) {
                        nodes.push(node);
                    }
                }
                return nodes;
            }

            // --- 4. Animation Functions ---

            function animateSearch(visitedNodes) {
                let i = 0;
                const interval = setInterval(() => {
                    if (i === visitedNodes.length) {
                        clearInterval(interval);
                        animateFinalPath();
                        return;
                    }
                    const node = visitedNodes[i];
                    if (node !== startNode && node !== endNode) {
                        node.draw(COLOR_VISITED);
                    }
                    i++;
                }, 10);
            }

            function animateFinalPath() {
                const path = [];
                let currentNode = endNode;
                while (currentNode !== null) {
                    path.push(currentNode);
                    currentNode = currentNode.previousNode;
                }
                path.reverse();
                currentPath = path;

                let i = 0;
                const interval = setInterval(() => {
                    if (i === path.length) {
                        clearInterval(interval);
                        toggleButtons(true);
                        isAnimating = false;
                        return;
                    }
                    const node = path[i];
                    if (node !== startNode && node !== endNode) {
                        node.draw(COLOR_PATH);
                    }
                    i++;
                }, 40);
            }
            
            // --- 5. Control Button Functions ---
            
            function toggleButtons(enabled) {
                document.getElementById('findPathBtn').disabled = !enabled;
                document.getElementById('clearPathBtn').disabled = !enabled;
                document.getElementById('clearWallsBtn').disabled = !enabled;
                document.getElementById('generateMazeBtn').disabled = !enabled;
            }

            function clearGrid() {
                if (isAnimating) return;
                currentPath = []; 
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        const node = grid[y][x];
                        node.isWall = false;
                        node.reset();
                    }
                }
                drawGrid();
            }

            function clearPath() {
                if (isAnimating) return;
                currentPath = []; 
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        grid[y][x].reset();
                    }
                }
                drawGrid();
            }

            // --- MODIFIED MAZE GENERATOR ---
            function generateMaze() {
                if (isAnimating) return;
            
                // 1. Start with a grid full of walls
                clearGrid();
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        grid[y][x].isWall = true;
                    }
                }
            
                // 2. Set up for maze generation
                const stack = [];
                const visitedMaze = Array(GRID_HEIGHT).fill(false).map(() => Array(GRID_WIDTH).fill(false));
            
                // 3. Start carving from cell (0, 0)
                let startX = 0, startY = 0;
                if (startX % 2 !== 0) startX++;
                if (startY % 2 !== 0) startY++;
                if (startX >= GRID_WIDTH) startX = 0;
                if (startY >= GRID_HEIGHT) startY = 0;

                let startCell = grid[startY][startX];
                startCell.isWall = false;
                visitedMaze[startY][startX] = true;
                stack.push(startCell);
            
                while (stack.length > 0) {
                    const current = stack[stack.length - 1];
                    const neighbors = [];
                    const { x, y } = current;
            
                    // Check neighbors 2 steps away
                    if (y > 1 && !visitedMaze[y - 2][x]) neighbors.push(grid[y - 2][x]);
                    if (y < GRID_HEIGHT - 2 && !visitedMaze[y + 2][x]) neighbors.push(grid[y + 2][x]);
                    if (x > 1 && !visitedMaze[y][x - 2]) neighbors.push(grid[y][x - 2]);
                    if (x < GRID_WIDTH - 2 && !visitedMaze[y][x + 2]) neighbors.push(grid[y][x + 2]);
            
                    if (neighbors.length > 0) {
                        const chosen = neighbors[Math.floor(Math.random() * neighbors.length)];
                        const wallX = (chosen.x + current.x) / 2;
                        const wallY = (chosen.y + current.y) / 2;
                        grid[wallY][wallX].isWall = false;
                        chosen.isWall = false;
                        visitedMaze[chosen.y][chosen.x] = true;
                        stack.push(chosen);
                    } else {
                        stack.pop();
                    }
                }
                
                // --- NEW: CREATE IMPERFECT MAZE (LOOPS) ---
                // Randomly remove a percentage of the remaining walls
                const removalPercentage = 0.15; // 15% chance to remove a wall
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        if (grid[y][x].isWall) {
                            if (Math.random() < removalPercentage) {
                                grid[y][x].isWall = false;
                            }
                        }
                    }
                }
                // --- END NEW SECTION ---
            
                // 4. Ensure start and end nodes are not walls
                startNode.isWall = false;
                endNode.isWall = false;
            
                // 5. Redraw the grid
                drawGrid();
            }
            // --- END MODIFIED MAZE GENERATOR ---
            

            // --- 6. Event Listeners ---

            function getMousePos(evt) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: evt.clientX - rect.left,
                    y: evt.clientY - rect.top
                };
            }

            function handleWallDrawing(evt) {
                if (isAnimating || currentPath.length > 0) return; 
                
                const { x, y } = getMousePos(evt);
                const col = Math.floor(x / CELL_SIZE);
                const row = Math.floor(y / CELL_SIZE);

                if (row >= 0 && row < GRID_HEIGHT && col >= 0 && col < GRID_WIDTH) {
                    const node = grid[row][col];
                    if (node !== startNode && node !== endNode) {
                        node.isWall = true;
                        node.draw(COLOR_WALL);
                    }
                }
            }

            canvas.addEventListener('mousedown', (e) => {
                if (isAnimating) return;

                const { x, y } = getMousePos(e);
                const col = Math.floor(x / CELL_SIZE);
                const row = Math.floor(y / CELL_SIZE);
                if (row < 0 || row >= GRID_HEIGHT || col < 0 || col >= GRID_WIDTH) return;
                
                const clickedNode = grid[row][col];

                if (currentPath.includes(clickedNode) && clickedNode !== startNode && clickedNode !== endNode) {
                    clickedNode.isWall = true;
                    currentPath = []; 
                    dijkstra(); 
                } 
                else if (currentPath.length === 0) {
                    isDrawing = true;
                    handleWallDrawing(e);
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDrawing || isAnimating || currentPath.length > 0) return;
                handleWallDrawing(e);
            });

            canvas.addEventListener('mouseup', () => {
                isDrawing = false;
            });
            
            canvas.addEventListener('mouseleave', () => {
                isDrawing = false;
            });

            // Button listeners
            document.getElementById('findPathBtn').addEventListener('click', dijkstra);
            document.getElementById('clearWallsBtn').addEventListener('click', clearGrid);
            document.getElementById('clearPathBtn').addEventListener('click', clearPath);
            document.getElementById('generateMazeBtn').addEventListener('click', generateMaze);
            
            // --- 7. Initial Run ---
            
            initializeGrid();
            drawGrid();

        });
    </script>

</body>
</html>
